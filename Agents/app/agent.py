"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/01_langgraph_text2sql.ipynb.

# %% auto 0
__all__ = ['llm_model', 'client', 'SQL_PREFIX', 'SQL_FUNCTIONS_SUFFIX', 'ROUTER_PREFIX', 'graph', 'tools', 'app', 'Connection',
           'GenieWarehouse', 'Message', 'HMessage', 'SMessage', 'AMessage', 'State', 'get_tables', 'describe_tables',
           'get_columns', 'check_sql_query', 'Pandas_code', 'check_pandas', 'Router', 'router', 'Code_interpreter',
           'write_sql', 'write_pandas', 'FinalAnswer', 'final_answer', 'should_continue']

# %% ../../nbs/01_langgraph_text2sql.ipynb 3
from pydantic import Field
from langgraph.graph import StateGraph, END

import pandas as pd
import instructor
from openai import OpenAI
from instructor import OpenAISchema
from typing import Literal, Dict, List, Sequence, TypedDict, Annotated, Any
from langchain_experimental.utilities.python import PythonREPL
from fastcore.basics import patch
import requests
import json
import time
import traceback
import operator
import os
import datetime

# %% ../../nbs/01_langgraph_text2sql.ipynb 4
class Connection(OpenAISchema):
    """Class that manage the connection to the database, Some base methods to bring description information, and other to execute queries"""

    sql_warehouse_id: str = "46b86d8bd3411918"
    instance: str = "https://adb-5039287245643288.8.azuredatabricks.net"
    # uri_sql_endpoint: str = f"{instance}/api/2.0/sql/statements/"
    # uri_sql_history: str = f"{instance}/api/2.0/sql/history/queries"
    catalog: str
    database: str
    token: str

    def generate_headers(self) -> Dict[str, str]:
        """Class method to generate the headers"""
        return {
            "Authorization": f"Bearer {self.token}",
            "Content-Type": "application/json",
        }

    def generate_data_post(
        self,
        query_to_execute: str,
        fmt: Literal["CSV", "ARROW_STREAM", "JSON_ARRAY"] = "JSON_ARRAY",
        disposition: Literal["INLINE", "diff"] = "INLINE",
    ) -> Dict[str, str]:
        """Method that generate the body of the post request to execute the query in the SQL Warehouse"""
        data = {
            "warehouse_id": f"{self.sql_warehouse_id}",
            "format": fmt,  # for big use CSV, ARROW_STREAM, JSON_ARRAY is default for small <25mb
            "disposition": disposition,  # for big security attention with token here, needs to be diff, INLINE is default
            "statement": query_to_execute,
            "catalog": f"{self.catalog}.{self.database}",
            "wait_timeout": "0s",
        }
        return data

    @classmethod
    def parse_result(cls, data: Dict) -> Dict[str, Any]:
        """Class method to parse the result into a dataframe compatible
        Args:
            data (Dict): data from the SQL Warehouse
        Returns:
            Dict: dictionary with columns and data
        """
        columns = [x["name"] for x in data["manifest"]["schema"]["columns"]]
        results = data["result"]["data_array"]
        return {"columns": columns, "data": results}


# %% ../../nbs/01_langgraph_text2sql.ipynb 5
@patch
def get_tables(
            self:'Connection'
        ) -> List[str]:
    """Method to list tables avaialbles
    Returns:
        List[str]: list of tables names
    """
    query = f"SHOW TABLES in {self.catalog}.{self.database}"
    data = self.execute_query(query)
    tables = data["data"]  # self.parse_result(data)['data']
    return [f"{self.catalog}.{x[0]}.{x[1]}" for x in tables if x[1].find("payload") == -1]

# %% ../../nbs/01_langgraph_text2sql.ipynb 6
@patch
def get_table_columns(
        self:'Connection',
        table: str
    ) -> List[str]:
    """Method to get the columns of a table
    Args:
        table (str): table name
    Returns:
        List[str]: list of columns
    """
    query = f"DESCRIBE TABLE {table}"
    data = self.execute_query(query)
    return [x[0] for x in data["data"]]  # self.parse_result(data)['data']]



# %% ../../nbs/01_langgraph_text2sql.ipynb 7
@patch
def get_tables_columns(
        self:'Connection', 
    ) -> Dict[str, List[str]]:
    """
    Method to get the tables and columns
    Returns:
        Dict[str, List[str]]: dictionary with table name as key and list of columns
    """
    tables = self.get_tables()
    tables_columns = {}
    for table in tables:
        table_columns = self.get_table_columns(table)
        tables_columns[table] = table_columns
    return tables_columns
    


# %% ../../nbs/01_langgraph_text2sql.ipynb 8
@classmethod
@patch
def row_2_str(
        cls:'Connection',
        row
    ):
    return f"{row[0]} ( {row[1] if row[1] else ''} {row[2] if row[2] else ''})"


# %% ../../nbs/01_langgraph_text2sql.ipynb 9
@classmethod
@patch
def list_cols(
        cls:'Connection',
        df
    ):
    end_i = df.loc[df['col_name'] == ''].index[0]
    cols = df.loc[:end_i-1] #usar i -1
    return cols.apply(lambda row: cls.row_2_str(row), axis=1).to_list()



# %% ../../nbs/01_langgraph_text2sql.ipynb 10
@patch
def get_table_description(
        self:'Connection', 
        table: str
    ) -> Dict[str, str]:
    """Method that returns the table description
    Args:
        table (str): table name
    Returns:
        Dict[str, str]: dictionary with table and description
    """
    query = f"DESCRIBE TABLE EXTENDED {table}"
    data = self.execute_query(query)
    df = pd.DataFrame(data['data'], columns = data['columns'])
    cols = self.list_cols(df)
    comment =  df.loc[df['col_name'] == 'Comment']['data_type'].values[0]
    return {"table": table, "description": comment, "columns":cols}  # data #self.parse_result(data)


# %% ../../nbs/01_langgraph_text2sql.ipynb 11
@patch
def get_tables_descriptions(
        self:'Connection',
        tables: list[str] | None = None
    ) -> List[Dict[str, str]]:
    """Function that return the tables and the description
    Args:
        tables (list[str], optional): list of tables. Defaults to None.
    Returns:
        List[Dict[str, str]]: list of dictionaries with table and description
    """
    tables = tables if tables else self.get_tables()
    tables_description = []
    for table in tables:
        table_desc = self.get_table_description(table)
        tables_description.append(table_desc)
    return tables_description


# %% ../../nbs/01_langgraph_text2sql.ipynb 12
@patch
def execute_query(
        self:'Connection', 
        query: str
    ):
    """Method that execute the query in the SQL Warehouse
    Args:
        query (str): query to execute
    Returns:
        Dict: dictionary with the result of the query
    """
    response = requests.post(
        self.uri_sql_endpoint,
        headers=self.generate_headers(),
        data=json.dumps(self.generate_data_post(query)),
    )
    data = response.json()
    while data["status"]["state"] != "SUCCEEDED":
        status = data["status"]["state"] 
        match status:
            case "RUNNING":
                time.sleep(0.5)
                response = requests.get(
                    self.uri_sql_endpoint + data["statement_id"],
                    headers=self.generate_headers(),
                )
                data = response.json()
            case "PENDING":
                time.sleep(0.5)
                response = requests.get(
                    self.uri_sql_endpoint + data["statement_id"],
                    headers=self.generate_headers(),
                )
                data = response.json()
            case "FAILED":
                raise Exception(traceback.format_exc())
    return self.parse_result(data)

# %% ../../nbs/01_langgraph_text2sql.ipynb 14
class GenieWarehouse(OpenAISchema):
    """Class with all information to connect and query the warehouse
    Args:
        catalog (str): catalog name
        connection (Connection): connection to the warehouse
        tables (List[Any], optional): list of tables. Defaults to [].
        tables_description (List, optional): list of tables description. Defaults to [].
        tables_columns (Dict, optional): dictionary with table and columns. Defaults to {}.
    """

    catalog: str
    connection: Connection
    tables: List[Any] = []
    tables_data : List = []
    # tables_description: List = []
    # tables_columns: Dict = {}
    # tables_data: List = []

    def get_queries(self):
        """Method to list queries from the warehouse"""
        pass

    def get_tables(self) -> str:
        """Return the tables as string
        Returns:
            str: tables as string"""
        tables_string = "\n".join( [f"<table>{table}</table>" for table in self.tables])        
        return f"<tables>\n{tables_string}\n</tables>"

    def get_tables_description(self) -> str:
        """Method to return the tables description
        Returns:
            str: tables description as string
        """
        # tables_data = self.connection.get_tables_descriptions()
        # print(tables_data)
        results = []
        for table_name in self.tables:
            results.append(self.get_table_description(table_name, self.tables_data))
        string =  "\n".join(results)
        return f"<tables_descriptions>\n{string}\n</tables_descriptions>"

    def dict_2_str(self, data: Dict) -> str:
        """Method to convert a dictionary to string
        Args:
            data (Dict): dictionary
        Returns:
            str: dictionary as string
        """
        return ", ".join([v for k, v in data.items()])

    def get_table_description(self, table: str, tables_data:List) -> str:
        """Method to get the table description
        Args:
            table (str): table name
        Returns:
            str: table description as string
        """
        tables_description = [{x['table']: x['description']} for x in self.tables_data]
        description = [x['description'] for x in self.tables_data if x['table'] == table]
        return f"<description table={table}>{description[0]}</description>" if description else f"<description table={table}>No description</description>"

    def get_tables_columns(self) -> str:
        """Method to return the tables columns
        Returns:
            str: tables columns as string
        """
        # tables_data = self.connection.get_tables_descriptions()
        tables_columns = {x['table']: x['columns'] for x in self.tables_data}
        results = []
        for table_name in self.tables: 
            results.append(self.get_table_columns(tables_columns, table_name))
        string = "\n".join(results)
        return f"<tables_columns>\n{string}\n</tables_columns>"

    def get_table_columns(self, columns: List, table:str) -> str:
        """Method to get the columns of a table
        Args:
            table (str): table name
        Returns:
            str: columns as string
        """
        columns = [x['columns'] for x in self.tables_data  if x['table'] == table]
        strings = [f"<col>{x}</col>" for x in columns[0]]
        return f"<columns table={table}>{''.join(strings)}</columns>"

    def get_db_information(self):
        """ Method that generates an structured tables information"""
        results = []
        for table in self.tables_data:
            string = f"""<table>{table['table']}</table>
            <description>{table['description']}</description>
            <columns>{''.join([f"<col>{x}</col>" for x in table['columns']])}</columns>"""
            results.append(string)
            # results.append(self.get_table_description(table, self.tables_data))
            # results.append(self.get_table_columns(table, self.tables_data))
        return "\n".join(results)

    def execute(self, query: str) -> str | Dict[str, Any]:
        """Method to execute the query
        Args:
            query (str): query to execute
        Returns:
            str| Dict[str, Any]: response of the query
        """
        try:
            response = self.connection.execute_query(query)
        except Exception as e:
            response = f"ERROR: {e}"
        return response

    @classmethod
    def from_catalog(
        cls,
        token: str,
        catalog: str = "cat_holding_ai_dev",
        database: str = "db_llm_genie",
    ):
        """Class method to create the instance from the catalog
        Args:
            catalog (str, optional): catalog name. 
            database (str, optional): database name. 
            token (str, optional): token. 
        Returns:
            GenieWarehouse: instance of the class
        """
        connection = Connection(token=token, catalog=catalog, database=database)
        tables = connection.get_tables()
        tables_data = connection.get_tables_descriptions()
        # tables_columns = {x['table']: x['columns'] for x in tables_data}
        # tables_description = [{x['table']: x['description']} for x in tables_data]

        return cls(
            catalog=catalog,
            connection=connection,
            tables_data = tables_data,
            tables=tables,
            # tables_columns=tables_columns,
            # tables_description=tables_description,
        )

# %% ../../nbs/01_langgraph_text2sql.ipynb 26
class Message(OpenAISchema):
    """Class that manage the messages
    Args:
        role (str): role of the message
        content (str): content of the message
        imgs (List[str], optional): list of images. Defaults to [].
    """

    role: str
    content: str
    name: str | None = None
    sql: str | None = None
    plot: str| None = None
    data: List[Dict[Any,Any]] | None = None
    imgs: List[str] = []

    def to_string(self):
        return f"{self.role.upper()}: {self.content}"

    def to_dict(self):
        return {"role": self.role, "content": self.content}
    
    def to_api(self):
        # content = self.content if 
        return {
            "role": self.role, 
            "content": self.content,
            "sql": self.sql,
            "plot": self.plot,
            "data": self.data,
            "imgs": self.imgs
        }


class HMessage(Message):
    """Class that manage the User messages
    Args:
        role (str): role of the message
        content (str): content of the message
        imgs (List[str], optional): list of images. Defaults to [].
    """

    role: str = "user"

    def history(self):
        return {"question": self.content}


class SMessage(Message):
    """Class that manage the System messages
    Args:
        role (str): role of the message
        content (str): content of the message
        imgs (List[str], optional): list of images. Defaults to [].
    """

    role: str = "system"


class AMessage(Message):
    """Class that manage the Assistant messages
    Args:
        role (str): role of the message
        content (str): content of the message
        imgs (List[str], optional): list of images. Defaults to [].
    """

    role: str = "assistant"

    def history(self):
        return {"answer": self.content}

# %% ../../nbs/01_langgraph_text2sql.ipynb 29
class State(TypedDict):
    """Class that manage the state of the agent
    Args:
        message (Message): message
        history (Sequence[Message]): history of the messages
        next (str): next tool to call
        parameters (Dict[str, Any]): parameters to be used in the next tool
        code (str): code to be executed
        connection (GenieWarehouse): connection to the SQL Warehouse
        dataframe (pd.DataFrame): dataframe to be used in the code
        error (str): error message if the code is not correct
    """

    message: Message
    history: Annotated[Sequence[Message], operator.add]
    next: str = Field(
        ...,
        description="The next tool to call from the available tools",
        enum=[
            "get_tables",
            "describe_tables",
            "get_columns",
            "write_sql_queries",
            "write_pandas",
            "final_answer",
        ],
    )
    code: str = Field(None, description="SQL code to be executed.")
    python: Dict = Field(None, description="Python code to be executed.")
    connection: GenieWarehouse = Field(
        ..., description="Connection to the SQL Warehouse"
    )
    dataframe: pd.DataFrame | None = Field(
        None, description="Dataframe to be used in the code."
    )
    error: str | None = Field(
        None, description="Error message if the code is not correct."
    )

# %% ../../nbs/01_langgraph_text2sql.ipynb 31
def get_tables(state: State):
    """Function to get the tables available
    Args:
        state (State): state of the graph
    Returns:
        Dict: dictionary with the history of the message
    """
    connection = state["connection"]
    tables = connection.get_tables()
    message = f"The available tables are:\n{tables}"
    return {"history": [HMessage(content=message)]}

# %% ../../nbs/01_langgraph_text2sql.ipynb 33
def describe_tables(state):
    """Function to describe the table
    Args:
        state (State): state of the graph
    Returns:
        Dict: dictionary with the history of the message
    """
    connection = state["connection"]
    table_description = connection.get_tables_description()
    message = f"Below are the tables and its descrpition:\n{table_description}"
    return {"history": [HMessage(content=message)]}

# %% ../../nbs/01_langgraph_text2sql.ipynb 35
def get_columns(state):
    """Function to get the columns
    Args:
        state (State): state of the graph
    Returns:
        Dict: dictionary with the history of the message
    """
    connection = state["connection"]
    # params = ["parameters"]
    # if "table" in params:
    #     table = state["parameters"]["table"]
    #     columns = connection.get_table_columns(table)
    # else:
    columns = connection.get_tables_columns()
    message = f"The tables at they columns are:\n{columns}"
    return {"history": [HMessage(content=message)]}

# %% ../../nbs/01_langgraph_text2sql.ipynb 37
def check_sql_query(state):
    """Function to check the SQL query
    Args:
        state (State): state of the graph
    Returns:
        Dict: dictionary with the history of the message
    """
    connection = state["connection"]
    query = state["code"]
    try:
        response = connection.execute(query)
        
        error = ""
        df = pd.DataFrame(response["data"], columns=response["columns"])
        df = df.apply(pd.to_numeric, errors='ignore')
        message = f"The SQL query returned:\n{df.head(50).to_csv()}"
        next = 'router'
    except Exception as e:
        error = traceback.format_exc()
        message = f"The SQL query was wrong and returned the error:\n{e}\nTraceback:\n{error}"
        df = None
        next = 'write_sql_queries'
    return {"history": [HMessage(content=message)], "dataframe": df, "error": error, 'next':next}

# %% ../../nbs/01_langgraph_text2sql.ipynb 39
class Pandas_code(OpenAISchema):
    """Class that represnts the code to generate graph in pandas"""

    code: str = Field(
        ...,
        description="Correctly wrote Python code to plot the dataframe using plotly library.",
    )
    imports: str = Field(..., description="Imports needed for the code.")
    error: str | None = Field(
        None, description="Error message if the code is not correct."
    )
    returns: Any | None = Field(
        None, description="Returns the figure data after execution."
    )

    def execute(self, data: pd.DataFrame):
        """method to execute the action item"""
        python = PythonREPL()
        if self.code:
            python.globals["df"] = data
            python.globals["fig"] = None
            try:
                print(f"fig before executing: {python.globals['fig']}")
                python.run(self.code + "\n" + "globals()['fig'] = fig")
                print(f"fig after executing: {python.globals['fig']}")
                self.returns = python.globals["fig"].to_json()
                if not self.returns:
                    raise Exception("ERROR: The code does not returned the figure")
            except Exception as e:
                self.error = f"ERROR: {e}\n{traceback.format_exc()}"
                raise Exception(f"ERROR: {e}\nTraceback: {traceback.format_exc()}")
        return

# %% ../../nbs/01_langgraph_text2sql.ipynb 41
def check_pandas(state):
    """Node taht checks the panda code and execute it
    Args:
        state (State): state of the graph
    Returns:
        Dict: dictionary with the history of the message
    """
    code = Pandas_code(**state["python"])
    try:
        _ = code.execute(state["dataframe"])
        next = 'final_answer'
        code = code
        message = "The plot was genearted successfully"
    except Exception as e:
        next = 'write_pandas'
        code = code
        error = code.error
        message = f"The code:{code}\n was wrong and returned the error:\n{e}\nTraceback:\n{error}"
    return {"python": code, "next": next, "error": code.error, "history": [HMessage(content=message)]}

# %% ../../nbs/01_langgraph_text2sql.ipynb 43
llm_model = "azure-openai-gpt-4o-endpoint"

client = instructor.patch(
    OpenAI(
        api_key=os.environ.get("DATABRICKS_TOKEN"),
        base_url=os.environ.get("LLM_ENDPOINT")
    ),
    mode=instructor.Mode.TOOLS,
)

# %% ../../nbs/01_langgraph_text2sql.ipynb 45
SQL_PREFIX = f"""You are an agent designed to interact with a SQL database from DataBricks.
Given an input question, create a syntactically correct SQL query to run.
Never query for all the columns from a specific table, only ask for the relevant columns given the question.
Always return the end result ordered by the most relevant column.
You MUST double check your query before executing it. If you get an error while executing a query, rewrite the query and try again.

DO NOT make any DML statements (INSERT, UPDATE, DELETE, DROP etc.) to the database.
Today is {datetime.date.today().strftime("%B %d, %Y")}.
"""

SQL_FUNCTIONS_SUFFIX = """I should look at the tables in the database to see what I can query.  Then I should query the schema of the most relevant tables."""


# %% ../../nbs/01_langgraph_text2sql.ipynb 47
ROUTER_PREFIX = """Think step by step and plan each step to gather the information required to succesfully answer the user's question.

You have some tools to interact with the database:
- Get the tables available in the database use 'get_tables' tool.
- Describe a table in the database. 'describe_tables' tool.
- Get the columns of a table in the database. 'get_columns' tool.
- Generate and check a SQL query in the database. 'write_sql_queries' tool.
- Generate a python code to generate an engaging graph. 'write_pandas' tool.

When you have the information needed, answer the user using the tool 'final_answer'
"""

# %% ../../nbs/01_langgraph_text2sql.ipynb 49
class Router(OpenAISchema):
    """Class to route the messages"""

    next: str = Field(
        ...,
        description="The next tool to call from the available tools",
        enum=[
            "get_tables",
            "describe_tables",
            "get_columns",
            "write_sql_queries",
            "write_pandas",
            "final_answer",
        ],
    )

# %% ../../nbs/01_langgraph_text2sql.ipynb 50
def router(state):
    """
    Router to guide the agent
    """
    data: Router = client.chat.completions.create(
        model=llm_model,
        response_model=Router,
        messages=[
            {"role": "system", "content": ROUTER_PREFIX},
            state["message"].to_dict(),
            *[x.to_dict() for x in state["history"]],
        ],
    )
    print(data.next)
    return {"next": data.next}

# %% ../../nbs/01_langgraph_text2sql.ipynb 52
class Code_interpreter(OpenAISchema):
    """Class that represnts the code interpreter strucuter"""

    code: str = Field(
        ...,
        description="Correctly wrote SQL query to retrieve the data needed by the agent.",
    )
    error: str | None = Field(
        None, description="Error message if the code is not correct."
    )

# %% ../../nbs/01_langgraph_text2sql.ipynb 54
def write_sql(state):
    """code_generation: Code_interpreter = Field(None, description="Code interpreter for the agent.")
    answer: str = Field(None, description="Answer from the agent.")
    next: str = Field(None, description="Next step for the agent.")
    """
    data: Code_interpreter = client.chat.completions.create(
        model=llm_model,
        response_model=Code_interpreter,
        messages=[
            {"role": "system", "content": SQL_PREFIX},
            state["message"].to_dict(),
            *[x.to_dict() for x in state["history"]],
        ],
    )
    code = data.code.strip(";")
    print(code)
    return {"code": code, 'history': [HMessage(content=code)]}    

# %% ../../nbs/01_langgraph_text2sql.ipynb 56
def write_pandas(state):
    """ """
    data: Pandas_code = client.chat.completions.create(
        model=llm_model,
        response_model=Pandas_code,
        messages=[
            {
                "role": "system",
                "content": """You are an experienced data analyst, and you will generate the correct python code to graphically presents the data with the library 'plotly'.
                Before start, think step by step on the best and most engaging graph to answer the user question with the avaialble data, double check the code. All the titles, labels, legends, and text MUST be written Brazilian portuguese.
                """,
            },
            state["message"].to_dict(),
            {
                "role": "user",
                "content": f"""Given the following dataframe 'df', create an engaging plot to answer the user's question.
                Separate the code by imports and code.
                When you ran the command '''python 
                  df.head(3)
                  ''' 
                  you got:
                  {state['dataframe'].head(3)}.

                  Never show the plot, just assign it to the variable 'fig'.
                  """,
            },
            {
                "role":"user",
                "content":"All the titles, labels, legends, and text MUST be written Brazilian portuguese"
            }
        ],
    )
    return {"python": data.model_dump(), 'history': [HMessage(content=data.code)]}

# %% ../../nbs/01_langgraph_text2sql.ipynb 57
class FinalAnswer(OpenAISchema):
    """The final answer to the user"""

    answer: str = Field(
        ...,
        description="A detailed and explanatory final answer based on the question and the data.",
    )

# %% ../../nbs/01_langgraph_text2sql.ipynb 59
def final_answer(state):
    """
    Generate the final answer to user's question
    """
    if isinstance(state["dataframe"], pd.DataFrame):
        agent_messages = [
            {"role": "user", "content": f"Here is the data you requested:\n{state['dataframe'].head(20)}"},
            state["history"][-1].to_dict()
        ]
    else:
        agent_messages = [
            *[x.to_dict() for x in state["history"]],
            {"role": "user", "content": f"Be conversational, and guide me to ask about data or ask for clarification"},
        ]
    data: FinalAnswer = client.chat.completions.create(
        model=llm_model,
        response_model=FinalAnswer,
        messages=[
            {
                "role": "system",
                "content": f"""Your name is GAB Lakehouse, and you are a senior Data Analyst that assist the user to answer all his question about data, in a detailed and explanatory way.
                Today is {datetime.date.today().strftime("%B %d, %Y")}.
""",
            },
            state["message"].to_dict(),
            *agent_messages,
            # {"role": "user", "content": state["dataframe"].head(20).to_csv() if isinstance(state["dataframe"], pd.DataFrame) else "Be conversational, and guide me to ask about data or ask for clarification"},
            {"role": "user", "content": "Always answer in Portugues from Brazil"},
        ],
    )
    message = data.answer
    state["message"] = AMessage(content=message)
    print(message)
    return state

# %% ../../nbs/01_langgraph_text2sql.ipynb 61
graph = StateGraph(State)
tools = [
    "get_tables",
    "describe_tables",
    "get_columns",
    "write_sql_queries",
    "write_pandas",
    "final_answer",
]
graph.add_node("get_tables", get_tables)
graph.add_node("get_columns", get_columns)
graph.add_node("describe_tables", describe_tables)
graph.add_node("check_sql_query", check_sql_query)
graph.add_node("write_sql_queries", write_sql)
graph.add_node("final_answer", final_answer)
graph.add_node("write_pandas", write_pandas)
graph.add_node("check_pandas", check_pandas)

graph.add_node("router", router)

graph.set_entry_point("router")

graph.add_edge("get_tables", "router")
graph.add_edge("get_columns", "router")
graph.add_edge("describe_tables", "router")
graph.add_edge("write_sql_queries", "check_sql_query")
graph.add_edge("check_sql_query", "router")
graph.add_edge("write_pandas", "check_pandas")
graph.add_edge("final_answer", END)


def should_continue(state):
    """ """
    return state["next"]


graph.add_conditional_edges("router", should_continue, {v: v for v in tools})
graph.add_conditional_edges(
    "check_pandas",
    should_continue,
    {"write_pandas": "write_pandas", "final_answer": "final_answer"},
)
app = graph.compile()
    # return app
