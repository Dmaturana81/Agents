"""Planning agent using instructor library"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/01_Databricks_text2sql.ipynb.

# %% auto 0
__all__ = ['llm_model', 'client', 'SQL_PREFIX', 'SQL_FUNCTIONS_SUFFIX', 'ROUTER_PREFIX', 'graph', 'tools', 'app', 'Message',
           'HMessage', 'SMessage', 'AMessage', 'Connection_db', 'GenieWarehouse', 'State', 'get_tables',
           'describe_tables', 'get_columns', 'check_sql_query', 'Pandas_code', 'check_pandas', 'Router', 'router',
           'Code_interpreter', 'write_sql', 'write_pandas', 'FinalAnswer', 'final_answer', 'should_continue']

# %% ../../nbs/01_Databricks_text2sql.ipynb 9
from pydantic import Field, model_validator
from langgraph.graph import StateGraph, END, START
from databricks import sql

import pandas as pd
import instructor
from openai import OpenAI
from instructor import OpenAISchema
from typing import Literal, Dict, List, Sequence, TypedDict, Annotated, Any
from langchain_experimental.utilities.python import PythonREPL
from fastcore.basics import patch
import requests
import json
import time
import traceback
import operator
import os
import datetime 

# %% ../../nbs/01_Databricks_text2sql.ipynb 11
class Message(OpenAISchema):
    """Class that manage the messages
    Args:
        role (str): role of the message
        content (str): content of the message
        imgs (List[str], optional): list of images. Defaults to [].
    """

    role: str
    content: str
    name: str | None = None
    sql: str | None = None
    plot: str| None = None
    data: List[Dict[Any,Any]] | None = None
    imgs: List[str] = []

    def to_string(self):
        return f"{self.role.upper()}: {self.content}"

    def to_dict(self):
        return {"role": self.role, "content": self.content}
    
    def from_agent(self):
        return {"role": self.role, "content": f"{self.name}: {self.content}"}
    
    def to_api(self):
        # content = self.content if 
        return {
            "role": self.role, 
            "content": self.content,
            "sql": self.sql,
            "plot": self.plot,
            "data": self.data,
            "imgs": self.imgs
        }


class HMessage(Message):
    """Class that manage the User messages
    Args:
        role (str): role of the message
        content (str): content of the message
        imgs (List[str], optional): list of images. Defaults to [].
    """

    role: str = "user"

    def history(self):
        return {"question": self.content}


class SMessage(Message):
    """Class that manage the System messages
    Args:
        role (str): role of the message
        content (str): content of the message
        imgs (List[str], optional): list of images. Defaults to [].
    """

    role: str = "system"


class AMessage(Message):
    """Class that manage the Assistant messages
    Args:
        role (str): role of the message
        content (str): content of the message
        imgs (List[str], optional): list of images. Defaults to [].
    """

    role: str = "assistant"

    def history(self):
        return {"answer": self.content}

# %% ../../nbs/01_Databricks_text2sql.ipynb 14
class Connection_db(OpenAISchema):
    """Class to connect and execute queries in the SQL Warehouse"""
    server_hostname: str # Databricks server hostname
    http_path: str # Databricks http path
    catalog: str # Databricks catalog
    database: str # Databricks database
    token: str # Databricks token
    cursor: Any # Cursor to execute the queries

    @model_validator(mode='before')
    @classmethod
    def connect(cls, values):
        """Method that validate the conexion and genrate it from the original data"""
        connector = sql.connect(server_hostname=values['server_hostname'], http_path=values['http_path'], catalog=values['catalog'],  access_token=values['token'])
        values['cursor'] = connector.cursor()
        return values


# %% ../../nbs/01_Databricks_text2sql.ipynb 17
@patch
def execute_query(
        self:Connection_db, #self object
        query: str #query to execute
    )-> dict: #Retorna o resultado da query em um dicionario
    """Method that execute the query in the SQL Warehouse
    Args:
        query (str): query to execute
    Returns:
        Dict: dictionary with the result of the query
    """
    response = self.cursor.execute(query)
    data = response.fetchall()
    return self.parse_result(data)


# %% ../../nbs/01_Databricks_text2sql.ipynb 21
@patch
def get_table_description(
        self:Connection_db, # self object
        table: str # table name
    ) -> Dict[str, str]: # dictionary with table and description
    """Method that returns the table description from Databricks
    Args:
        table (str): table name
    Returns:
        Dict[str, str]: dictionary with table and description
    """
    query = f"DESCRIBE TABLE EXTENDED {table}"
    data = self.execute_query(query)
    df = pd.DataFrame(data['data'], columns = data['columns'])
    cols = self.list_cols(df)
    comment =  df.loc[df['col_name'] == 'Comment']['data_type'].values[0]
    return {"table": table, "description": comment, "columns":cols}  # data #self.parse_result(data)


# %% ../../nbs/01_Databricks_text2sql.ipynb 23
@patch
def get_tables_descriptions(
        self:Connection_db, # self object
        tables: list[str] | None = None # list of tables names
    ) -> List[Dict[str, str]]: # list of dictionaries with table and description
    """Function that return the tables and the description
    Args:
        tables (list[str], optional): list of tables. Defaults to None.
    Returns:
        List[Dict[str, str]]: list of dictionaries with table and description
    """
    tables = tables if tables else self.get_tables()
    tables_description = []
    for table in tables:
        table_desc = self.get_table_description(table)
        tables_description.append(table_desc)
    return tables_description


# %% ../../nbs/01_Databricks_text2sql.ipynb 27
@classmethod
@patch
def row_2_str(
        cls:Connection_db,  # self object
        row # row to convert
    ):
    """Method to convert a column from the table description into a string, spcifying the name, type and comment availables
    Args:
        row: row to convert
    Returns:
        str: row as string
    """
    return f"{row[0]} ( {row[1] if row[1] else ''} {row[2] if row[2] else ''})"


# %% ../../nbs/01_Databricks_text2sql.ipynb 29
@classmethod
@patch
def list_cols(
        cls:Connection_db, # self object
        df: pd.DataFrame # dataframe with the columns
    ) -> List[str]: # list of columns as string
    """Method to list the columns of a table
    Args:
        df: dataframe with the columns
    Returns:
        List[str]: list of columns as string
    """
    end_i = df.loc[df['col_name'] == ''].index[0]
    cols = df.loc[:end_i-1] #usar i -1
    return cols.apply(lambda row: cls.row_2_str(row), axis=1).to_list()



# %% ../../nbs/01_Databricks_text2sql.ipynb 32
class GenieWarehouse(OpenAISchema):
    """Class with all information to connect and query the warehouse
    Args:
        catalog (str): catalog name
        connection (Connection): connection to the warehouse
        tables (List[Any], optional): list of tables. Defaults to [].
        tables_description (List, optional): list of tables description. Defaults to [].
        tables_columns (Dict, optional): dictionary with table and columns. Defaults to {}.
    """

    catalog: str # Databricks catalog
    connection:  Connection_db # Connection to the SQL Warehouse
    tables: List[Any] = [] # List of tables names
    tables_data : List = [] # List of tables descriptions


    def get_queries(self):
        """Method to list queries from the warehouse"""
        pass

    def get_tables(self) -> str:
        """Return the tables as string
        Returns:
            str: tables as string"""
        tables_string = "\n".join( [f"<table>{table}</table>" for table in self.tables])        
        return f"<tables>\n{tables_string}\n</tables>"

    def get_tables_description(self) -> str:
        """Method to return the tables description
        Returns:
            str: tables description as string
        """

        results = []
        for table_name in self.tables:
            results.append(self.get_table_description(table_name, self.tables_data))
        string =  "\n".join(results)
        return f"<tables_descriptions>\n{string}\n</tables_descriptions>"

    def dict_2_str(self, data: Dict) -> str:
        """Method to convert a dictionary to string
        Args:
            data (Dict): dictionary
        Returns:
            str: dictionary as string
        """
        return ", ".join([v for k, v in data.items()])

    def get_table_description(self, table: str, tables_data:List) -> str:
        """Method to get the table description
        Args:
            table (str): table name
        Returns:
            str: table description as string
        """
        tables_description = [{x['table']: x['description']} for x in self.tables_data]
        description = [x['description'] for x in self.tables_data if x['table'] == table]
        return f"<description table={table}>{description[0]}</description>" if description else f"<description table={table}>No description</description>"

    def get_tables_columns(self) -> str:
        """Method to return the tables columns
        Returns:
            str: tables columns as string
        """
        # tables_data = self.connection.get_tables_descriptions()
        tables_columns = {x['table']: x['columns'] for x in self.tables_data}
        results = []
        for table_name in self.tables: 
            results.append(self.get_table_columns(tables_columns, table_name))
        string = "\n".join(results)
        return f"<tables_columns>\n{string}\n</tables_columns>"

    def get_table_columns(self, columns: List, table:str) -> str:
        """Method to get the columns of a table
        Args:
            table (str): table name
        Returns:
            str: columns as string
        """
        columns = [x['columns'] for x in self.tables_data  if x['table'] == table]
        strings = [f"<col>{x}</col>" for x in columns[0]]
        return f"<columns table={table}>{''.join(strings)}</columns>"

    def get_db_information(self):
        """ Method that generates an structured tables information"""
        results = []
        for table in self.tables_data:
            string = f"""<table>{table['table']}</table>
            <description>{table['description']}</description>
            <columns>{''.join([f"<col>{x}</col>" for x in table['columns']])}</columns>"""
            results.append(string)
            # results.append(self.get_table_description(table, self.tables_data))
            # results.append(self.get_table_columns(table, self.tables_data))
        return "\n".join(results)

    def execute(self, query: str) -> str | Dict[str, Any]:
        """Method to execute the query
        Args:
            query (str): query to execute
        Returns:
            str| Dict[str, Any]: response of the query
        """
        try:
            response = self.connection.execute_query(query)
        except Exception as e:
            response = f"ERROR: {e}"
        return response

    @classmethod
    def from_catalog(
        cls,
        token: str,
        catalog: str = "cat_holding_ai_dev",
        database: str = "db_llm_genie",
        **kwargs
    ):
        """Class method to create the instance from the catalog
        Args:
            catalog (str, optional): catalog name. 
            database (str, optional): database name. 
            token (str, optional): token. 
        Returns:
            GenieWarehouse: instance of the class
        """
        connection = Connection(token=token, catalog=catalog, database=database, **kwargs)
        tables = connection.get_tables()
        tables_data = connection.get_tables_descriptions()


        return cls(
            catalog=catalog,
            connection=connection,
            tables_data = tables_data,
            tables=tables,
        )
    
    @classmethod
    def from_databricks_sql(
        cls,
        token: str,
        catalog: str = "text2sql",
        database: str = "default",
        server_hostname: str = os.environ.get("SQL_INSTANCE"),
        http_path: str = "/sql/1.0/warehouses/80623503f797f914",
    ):
        connection = Connection_db(server_hostname=server_hostname, http_path=http_path, catalog = catalog, database = database, token=token)
        tables = connection.get_tables()
        tables_data = connection.get_tables_descriptions()

        return cls(
            catalog=catalog,
            connection=connection,
            tables_data = tables_data,
            tables=tables,
        )

# %% ../../nbs/01_Databricks_text2sql.ipynb 41
class State(TypedDict):
    """Class that manage the state of the agent
    Args:
        message (Message): message
        history (Sequence[Message]): history of the messages
        next (str): next tool to call
        parameters (Dict[str, Any]): parameters to be used in the next tool
        code (str): code to be executed
        connection (GenieWarehouse): connection to the SQL Warehouse
        dataframe (pd.DataFrame): dataframe to be used in the code
        error (str): error message if the code is not correct
    """

    message: Message # Message to be used in the agent
    history: Annotated[Sequence[Message], operator.add] # History of the messages
    next: str = Field(
        ...,
        description="The next tool to call from the available tools",
        enum=[
            "get_tables",
            "describe_tables",
            "get_columns",
            "write_sql_queries",
            "write_pandas",
            "final_answer",
        ],
    ) # Next tool to call
    code: str = Field(None, description="SQL code to be executed.") # SQL code to be executed
    python: Dict = Field(None, description="Python code to be executed.") # Python code to be executed
    connection: GenieWarehouse = Field(
        ..., description="Connection to the SQL Warehouse"
    ) # Connection to the SQL Warehouse
    dataframe: pd.DataFrame | None = Field(
        None, description="Dataframe to be used in the code."
    ) # Dataframe to be used in the code
    error: str | None = Field(
        None, description="Error message if the code is not correct."
    ) # Error message if the code is not correct
    sql_write_passes: int = Field(0, description="Number of times the SQL query was written and passed.") # Number of times the SQL query was written and passed

# %% ../../nbs/01_Databricks_text2sql.ipynb 44
def get_tables(
        state: State # state of the graph
        ) -> State: # dictionary with the state of the graph
    """Function to get the tables available
    Args:
        state (State): state of the graph
    Returns:
        Dict: dictionary with the history of the message
    """
    connection = state["connection"]
    tables = connection.get_tables()
    message = f"The available tables are:\n{tables}"
    return {"history": [HMessage(content=message)]}

# %% ../../nbs/01_Databricks_text2sql.ipynb 47
def describe_tables(
        state: State # state of the graph
        ) -> State: # dictionary with the state of the message
    """Function to describe the table
    Args:
        state (State): state of the graph
    Returns:
        Dict: dictionary with the history of the message
    """
    connection = state["connection"]
    table_description = connection.get_tables_description()
    message = f"Below are the tables and its descrpition:\n{table_description}"
    return {"history": [HMessage(content=message)]}

# %% ../../nbs/01_Databricks_text2sql.ipynb 50
def get_columns(
        state: State # state of the graph
        ) -> State: # dictionary with the state of the message
    """Function to get the columns
    Args:
        state (State): state of the graph
    Returns:
        Dict: dictionary with the history of the message
    """
    connection = state["connection"]
    columns = connection.get_tables_columns()
    message = f"The tables at they columns are:\n{columns}"
    return {"history": [HMessage(content=message)]}

# %% ../../nbs/01_Databricks_text2sql.ipynb 53
def check_sql_query(
        state: State # state of the graph
        ) -> State: # dictionary with the state of the message
    """Function to check the SQL query
    Args:
        state (State): state of the graph
    Returns:
        Dict: dictionary with the history of the message
    """
    connection = state["connection"]
    query = state["code"]
    try:
        response = connection.execute(query)
        if not 'data' in response:
            message = f"The SQL query ```sql {state['code']}``` did not returned any data, Try again."
            error = ""
            next = 'write_sql_queries' if state['sql_write_passes'] < 4 else 'final_answer'
            df = None
        else:
            error = ""
            df = pd.DataFrame(response["data"], columns=response["columns"])
            df = df.apply(pd.to_numeric, errors='ignore')
            message = f"The SQL query ```sql {state['code']}``` returned:\n{df.head(50).to_csv()}"
            next = 'router'
    except Exception as e:
        error = traceback.format_exc()
        message = f"The SQL query was wrong and returned the error:\n{e}\nTraceback:\n{error}"
        df = None
        next = 'write_sql_queries'
    return {"history": [HMessage(content=message)], "dataframe": df, "error": error, 'next':next, "sql_write_passes": state["sql_write_passes"] + 1}

# %% ../../nbs/01_Databricks_text2sql.ipynb 56
class Pandas_code(OpenAISchema):
    """Class that represnts the code to generate graph in pandas"""

    code: str = Field(
        ...,
        description="Correctly wrote Python code to plot the dataframe using plotly library.",
    ) # Python code to plot the dataframe using plotly library
    imports: str = Field(..., description="Imports needed for the code.") # Imports needed for the code
    error: str | None = Field(
        None, description="Error message if the code is not correct."
    ) # Error message if the code is not correct
    returns: Any | None = Field(
        None, description="Returns the figure data after execution."
    ) # Returns the figure data after execution

    def execute(
            self, # self object
            data: pd.DataFrame # dataframe to be used in the code
        ) -> None: # None
        """method to execute the action item"""
        python = PythonREPL(_globals={"df":data, "fig":None}, )
        # python
        if self.code:
            try:
                code = clean_code(self.code)
                print(f"Code to run: {code}\n\n")
                printed = python.run(code) # + "\n\n" + "print(fig.to_json())") #"\n" + "globals()['fig'] = fig" + 
                self.returns = json.loads(printed)
                print(f"{self.returns}")
                # self.returns = python.globals["fig"].to_json()
                if not self.returns:
                    raise Exception("ERROR: The code does not returned the figure")
            except Exception as e:
                self.error = f"ERROR: {e}\n{traceback.format_exc()}"
                raise Exception(f"ERROR: {e}\nTraceback: {traceback.format_exc()}")
        return
    


# %% ../../nbs/01_Databricks_text2sql.ipynb 61
def check_pandas(
        state: State # state of the graph
        ) -> State: # dictionary with the state of the message
    """Node taht checks the panda code and execute it
    Args:
        state (State): state of the graph
    Returns:
        Dict: dictionary with the history of the message
    """
    code = Pandas_code(**state["python"])
    try:
        _ = code.execute(state["dataframe"])
        next = 'final_answer'
        code = code
        message = "The plot was genearted successfully"
    except Exception as e:
        next = 'write_pandas'
        code = code
        error = code.error
        message = f"The code:{code}\n was wrong and returned the error:\n{e}\nTraceback:\n{error}"
    return {"python": code, "next": next, "error": code.error, "history": [HMessage(content=message)]}

# %% ../../nbs/01_Databricks_text2sql.ipynb 65
#| eval: false
llm_model = "gpt-4o-mini"

client = instructor.from_openai(
    OpenAI(
        api_key=os.environ.get("OPENAI_API_KEY"),
    ),
)

# %% ../../nbs/01_Databricks_text2sql.ipynb 67
SQL_PREFIX = f"""You are an agent designed to interact with a SQL database from DataBricks.
Given an input question, create a syntactically correct SQL query to run. Always use the tables and columns that are available in the database.
As these is a database from scrapped information, the data is of varied formats, always try to use regular expressions or loosy matches.
Never query for all the columns from a specific table, only ask for the relevant columns given the question.
Always return the end result ordered by the most relevant column.
You MUST double check your query before executing it. If you get an error while executing a query, rewrite the query and try again.

DO NOT make any DML statements (INSERT, UPDATE, DELETE, DROP etc.) to the database.
Today is {datetime.date.today().strftime("%B %d, %Y")}.
"""

SQL_FUNCTIONS_SUFFIX = """I should look at the tables in the database to see what I can query.  Then I should query the schema of the most relevant tables."""


# %% ../../nbs/01_Databricks_text2sql.ipynb 69
ROUTER_PREFIX = """Think step by step and plan each step to gather the information required to succesfully answer the user's question.

You have some tools to interact with the database:
- Get the tables available in the database use 'get_tables' tool.
- Describe a table in the database. 'describe_tables' tool.
- Get the columns of a table in the database. 'get_columns' tool.
- Generate and check a SQL query in the database. 'write_sql_queries' tool.
- Generate a python code to generate an engaging graph. 'write_pandas' tool.

When you have the information needed, answer the user using the tool 'final_answer'
"""

# %% ../../nbs/01_Databricks_text2sql.ipynb 71
class Router(OpenAISchema):
    """Class to route the messages"""

    next: str = Field(
        ...,
        description="The next tool to call from the available tools",
        enum=[
            "get_tables",
            "describe_tables",
            "get_columns",
            "write_sql_queries",
            "write_pandas",
            "final_answer",
        ],
    )

# %% ../../nbs/01_Databricks_text2sql.ipynb 72
def router(
        state: State # state of the graph
        ) -> State: # dictionary with the state of the message
    """
    Router to guide the agent
    """
    data: Router = client.chat.completions.create(
        model=llm_model,
        response_model=Router,
        messages=[
            {"role": "system", "content": ROUTER_PREFIX},
            state["message"].to_dict(),
            *[x.to_dict() for x in state["history"]],
        ],
    )
    print(data.next)
    return {"next": data.next}

# %% ../../nbs/01_Databricks_text2sql.ipynb 75
class Code_interpreter(OpenAISchema):
    """Class that represnts the code interpreter strucuter"""

    code: str = Field(
        ...,
        description="Correctly wrote SQL query to retrieve the data needed by the agent.",
    )
    error: str | None = Field(
        None, description="Error message if the code is not correct."
    )

# %% ../../nbs/01_Databricks_text2sql.ipynb 77
def write_sql(
        state: State # state of the graph
        ) -> State: # dictionary with the state of the message
    """code_generation: Code_interpreter = Field(None, description="Code interpreter for the agent.")
    answer: str = Field(None, description="Answer from the agent.")
    next: str = Field(None, description="Next step for the agent.")
    """
    data: Code_interpreter = client.chat.completions.create(
        model=llm_model,
        response_model=Code_interpreter,
        messages=[
            {"role": "system", "content": SQL_PREFIX},
            state["message"].to_dict(),
            *[x.to_dict() for x in state["history"]],
        ],
    )
    code = data.code.strip(";")
    print(code)
    return {"code": code, 'history': [HMessage(content=code)]}    

# %% ../../nbs/01_Databricks_text2sql.ipynb 80
def write_pandas(
        state: State # state of the graph
        ) -> State: # dictionary with the state of the message
    """Function that generates the python code to plot the dataframe using plotly library"""
    data: Pandas_code = client.chat.completions.create(
        model=llm_model,
        response_model=Pandas_code,
        messages=[
            {
                "role": "system",
                "content": """You are an experienced data analyst, and you will generate the correct python code to graphically presents the data with the library 'plotly'.
                Before start, think step by step on the best and most engaging graph to answer the user question with the avaialble data, double check the code. All the titles, labels, legends, and text MUST be written Brazilian portuguese.
                """,
            },
            state["message"].to_dict(),
            {
                "role": "user",
                "content": f"""Given the following dataframe 'df', create an engaging plot to answer the user's question.
                Separate the code by imports and code.
                When you ran the command '''python 
                  df.head(3)
                  ''' 
                  you got:
                  {state['dataframe'].head(3)}.

                  Never show the plot, just assign it to the variable 'fig'.
                  """,
            },
            {
                "role":"user",
                "content":"All the titles, labels, legends, and text MUST be written Brazilian portuguese"
            }
        ],
    )
    return {"python": data.model_dump(), 'history': [HMessage(content=data.code)]}

# %% ../../nbs/01_Databricks_text2sql.ipynb 82
class FinalAnswer(OpenAISchema):
    """The final answer to the user"""

    answer: str = Field(
        ...,
        description="A detailed and explanatory final answer based on the question and the data.",
    )

# %% ../../nbs/01_Databricks_text2sql.ipynb 84
def final_answer(
        state: State # state of the graph
        ) -> State: # dictionary with the state of the message
    """
    Generate the final answer to user's question
    """
    if isinstance(state["dataframe"], pd.DataFrame):
        agent_messages = [
            {"role": "user", "content": f"Here is the data you requested:\n{state['dataframe'].head(20)}"},
            state["history"][-1].to_dict()
        ]
    else:
        agent_messages = [
            *[x.to_dict() for x in state["history"]],
            {"role": "user", "content": f"Be conversational, and guide me to ask about data or ask for clarification"},
        ]
    data: FinalAnswer = client.chat.completions.create(
        model=llm_model,
        response_model=FinalAnswer,
        messages=[
            {
                "role": "system",
                "content": f"""Your name is GAB Lakehouse, and you are a senior Data Analyst that assist the user to answer all his question about data, in a detailed and explanatory way.
                Today is {datetime.date.today().strftime("%B %d, %Y")}.
""",
            },
            state["message"].to_dict(),
            *agent_messages,
            {"role": "user", "content": "Always answer in Portugues from Brazil"},
        ],
    )
    message = data.answer
    state["message"] = AMessage(content=message)
    print(message)
    return state

# %% ../../nbs/01_Databricks_text2sql.ipynb 88
graph = StateGraph(State)
tools = [
    "get_tables",
    "describe_tables",
    "get_columns",
    "write_sql_queries",
    "write_pandas",
    "final_answer",
]
graph.add_node("get_tables", get_tables)
graph.add_node("get_columns", get_columns)
graph.add_node("describe_tables", describe_tables)
graph.add_node("check_sql_query", check_sql_query)
graph.add_node("write_sql_queries", write_sql)
graph.add_node("final_answer", final_answer)
graph.add_node("write_pandas", write_pandas)
graph.add_node("check_pandas", check_pandas)

graph.add_node("router", router)

graph.set_entry_point("router")

graph.add_edge("get_tables", "router")
graph.add_edge("get_columns", "router")
graph.add_edge("describe_tables", "router")
graph.add_edge("write_sql_queries", "check_sql_query")
# graph.add_edge("check_sql_query", "router")
graph.add_edge("write_pandas", "check_pandas")
graph.add_edge("final_answer", END)


def should_continue(state):
    """ """
    return state["next"]


graph.add_conditional_edges("router", should_continue, {v: v for v in tools})
graph.add_conditional_edges(
    "check_pandas",
    should_continue,
    {"write_pandas": "write_pandas", "final_answer": "final_answer"},
)
graph.add_conditional_edges(
    "check_sql_query",
    should_continue,
    {"write_sql_queries": "write_sql_queries", "router": "router", "final_answer": "final_answer"},
)
app = graph.compile()
    # return app
